Title: Writeup for Project 3, Fall 2015
Date: 11/4/15
Group:  Jackson Brodeur     jbrodeur@usc.edu
        Dylan Davis         dylandav@usc.edu
        Matthew O'Brien     obrienm@usc.edu	
 
I. Requirements:
- Describe what's your understanding of the requirements from the assignment statement. With the requirement analysis, you would be clear about what you are supposed to do.

In Part 1 of the assignment we had to implement software-management of the TLB. To do this we also had to implement a form of software page translation for handling TLB misses as well as making sure the TLB state was set up properly on a context switch.
To show that this was working we had to run a single program larger than 32 pages and show that it could run to completion. 

In Part 2 we had to implement virtual memory. This involved having routines for moving a page between memory and disk and creating utilizing a swap file. We did not preload anything and thus had to keep track of every virutal page and its location. When memory was full we had to select a page to evict (either FIFO or random) which would be done with the help of an inverted page table. 
To demonstrate that we had properly implemented virtual memory we had to run two programs, each larger than the 32 pages of main memory, and show that they would run to completion. The easiest way to do this was to show that two instances of matmult would successfully run. 

In Part 3 ... [TODO]

II. Assumptions
	- Reasonable assumptions you take for your scheme.
	[TODO: think we need multiple swapfiles with the networking portion]

	We named our swap file "swapfile.txt"

III. Design:
- This section is to cover your logic and ideas as to how  you are going to solve the problem presented.  This should include a description of classes, algorithms, etc. This is not code. You must document ALL parts of a project.


We had to implement an inverted page table (IPT) for this part and we did so by inheriting from TranslationEntry and adding a field to keep track of the address space as shown below.

struct IPT : public TranslationEntry {
    
    AddrSpace* mySpace;
};

For the modified page table that would keep track of the location of our pages we also inherited TranslationEntry and added the fields to keep track of its location and byte offset as shown below.

struct PageTableEntry : public TranslationEntry {
    
    int byteOffset;
    
    int diskLocation;
};

We used the IPT to keep track of all the pages in the system that are in use which allowed us to find pages to throw out on page faults. And the new modified page table kept track of the location of a page, byte offset included, so that we could retrieve it when needed. 

The algorithms involved in this section involved how we decided which page to evict (FIFO or random). For the FIFO method we kept a queue and each time a page was loaded into memory we added it to the queue and then when a page needed to be evicted we chose the one at the front of the queue. For random we simply generated a random page number in the range of possible page numbers, 0 - 31. 

We implemented the memory management in the following steps:

0) Receive and validate a virtual address from CPU
1) Look in TLB
	- if in TLB, compute physical address
2) If not in TLB, look in IPT
	- if found, update TLB, compute physical address
3) If there's an IPT miss (needed virtual page is not in memory), look in page table
	a. Check page table for the location and byte offset of the needed virtual page
		- location would be in the executable, swap, or neither
		- if in a file then get the file byte offset
	b. Find a page of physical memory
		i. If memory is full then select a page to evict (FIFO or random)
		ii. If page is dirty, write it to the swapfile
		iii. Update the page table of the process owning the evicted page
		iv. If page belonged to current process check to see if it's in the TLB
			- copy the dirty bit to the IPT from the TLB
			- invalidate that TLB entry 
	c. Load needed virtual page to physical memory (if on disk)
	d. Update IPT, page table for needed virtual page, and TLB
	e. Restart instruction

IV. Implementation:
	+ Files Modified
		test/Makefile
		addrspace.h
		addrspace.cc
		exception.cc
		system.h
		system.cc
		main.cc
	+ Files added
		test/testvm.c

	+ Data Structures added, and the file they were added to.
		struct PageTableEntry : public TranslationEntry - addrspace.h
		struct IPT : public TranslationEntry - system.h

	+ Data Structures modified, and the file they were added to.
		-For example,
			class Lock		-- in file threads.cc/threads.h
			{
				//. Modified fields.
			}

	+ Functions added and in which file.
	+ Functions modified and in which file.

V. Testing:  (For each test case, you must show)
	+ How to test
- How to run the test cases, the commands, the arguments and so on.
	The default page replacement policy is FIFO but you can select either RAND or FIFO with the -P flag (i.e. -P RAND)
	To test parts 1 and 2 you can run the following command: "nachos -x ../test/vm" from the 'vm' directory.
	+ Test Output
 	This executes two matmult's and upon successful completion they will exit with value 7220 and will print these values out.

VI. Discussion:
	+ Experiment expectation.  (What is supposed to happen.)
	+ Experiment result.  (What actually happened.)
	+ Explanation
		- Explain your experiment result - how it proves what 
		  you were supposed to prove.

VIII. Miscellaneous:
- Whatever else you want the grader know about your development.  You can create your own subsections headings here.