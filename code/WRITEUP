Title: Writeup for Project 3, Fall 2015
Date: 11/4/15
Group:  Jackson Brodeur     jbrodeur@usc.edu
        Dylan Davis         dylandav@usc.edu
        Matthew O'Brien     obrienm@usc.edu	
 
I. Requirements:
- Describe what's your understanding of the requirements from the assignment statement. With the requirement analysis, you would be clear about what you are supposed to do.

In Part 1 of the assignment we had to implement software-management of the TLB. To do this we also had to implement a form of software page translation for handling TLB misses as well as making sure the TLB state was set up properly on a context switch.
To show that this was working we had to run a single program larger than 32 pages and show that it could run to completion. 

In Part 2 we had to implement virtual memory. This involved having routines for moving a page between memory and disk and creating utilizing a swap file. We did not preload anything and thus had to keep track of every virtual page and its location (such as in the executable, in the swapfile, or neither). When memory was full we had to select a page to evict (either FIFO or random) which would be done with the help of an inverted page table. 
To demonstrate that we had properly implemented virtual memory we had to run two programs, each larger than the 32 pages of main memory, and show that they would run to completion. The easiest way to do this was to show that two instances of matmult would successfully run. 

In Part 3 we had to implement remote procedure calls for the Lock and Condition system calls that were implemented in Project 2. We also had to implement new system calls and remote procedure calls for monitor variables. You need to be able create a monitor variable, get its value and set its value.

II. Assumptions
	- Reasonable assumptions you take for your scheme.

	We named our swap file "swapfile.txt‚Äù. Also, when there is a context switch, the TLB needs to be invalidated so we accomplished this by placing the invalidation code inside of  the SaveState function in addrspace.cc because this function is called every time there is a context switch. Something else we assumed was that when we invalidate a page of memory, the only thing that needs to be set is the valid bit (to false). All of the other fields can just be ignored. Thus when attempting to use a page of memory (such as to clear it) we only need to check the valid bit before doing this.

	The Server will always have machine ID 0. The Server will always be running before any instance of nacho that needs access to RPCs is started. All monitor variables will be integers. The writers of the user programs will correctly use locks and conditions to controll access to the shared data.

III. Design:
- This section is to cover your logic and ideas as to how  you are going to solve the problem presented.  This should include a description of classes, algorithms, etc. This is not code. You must document ALL parts of a project.


We had to implement an inverted page table (IPT) for this part and we did so by inheriting from TranslationEntry and adding a field to keep track of the address space as shown below.

struct IPT : public TranslationEntry {
    
    AddrSpace* mySpace;
};

For the modified page table that would keep track of the location of our pages we also inherited TranslationEntry and added the fields to keep track of its location and byte offset as shown below.

struct PageTableEntry : public TranslationEntry {
    
    int byteOffset;
    
    int diskLocation;
};

We used the IPT to keep track of all the pages in the system that are in use which allowed us to find pages to throw out on page faults. And the new modified page table kept track of the location of a page, byte offset included, so that we could retrieve it when needed. 

The algorithms involved in this section involved how we decided which page to evict (FIFO or random). For the FIFO method we kept a queue and each time a page was loaded into memory we added it to the queue and then when a page needed to be evicted we chose the one at the front of the queue. For random we simply generated a random page number in the range of possible page numbers, 0 - 31. 

We implemented the memory management in the following steps:

0) Receive and validate a virtual address from CPU
1) Look in TLB
	- if in TLB, compute physical address
2) If not in TLB, look in IPT
	- if found, update TLB, compute physical address
3) If there's an IPT miss (needed virtual page is not in memory), look in page table
	a. Check page table for the location and byte offset of the needed virtual page
		- location would be in the executable, swap, or neither
		- if in a file then get the file byte offset
	b. Find a page of physical memory
		i. If memory is full then select a page to evict (FIFO or random)
		ii. If page is dirty, write it to the swapfile
		iii. Update the page table of the process owning the evicted page
		iv. If page belonged to current process check to see if it's in the TLB
			- copy the dirty bit to the IPT from the TLB
			- invalidate that TLB entry 
	c. Load needed virtual page to physical memory (if on disk)
	d. Update IPT, page table for needed virtual page, and TLB
	e. Restart instruction

Part 3
        In order to replace the local syscall implementation with remote procedure calls to the server we need to create new data structures: ServerLock, ServerCV, and ServerMV

        - The ServerLock struct has the following data:
            char * name
            int owner
            deque<int>* waitQueue
            bool isBusy

        - The ServerCV struct has the following data:
            char * name
            int waitingLock
            deque<int> * cvWaitQueue

        - The ServerMV struct has the following data:
            char * name
            int value

        We also had to modify the existing syscalls to create and send a message to the server when the user program wanted to access the functionality of Locks, Conditions, or Monitors. The Monitor Variables are designed in a way that it is up to the user program to use locks and conditions properly to control access to the shared data. We also had to create the Server program that woulde receive and handle all requests from the user programs. We used the fact that clients that invoked the postOffice::receive() method would wait until they got a response to simulate the sleeping and waking of threads induced by locks and condition variables.

        The format of a message from the client to the server would first have an integer, saying which function should be called on the server side followed by any arguments required by that function. All arguments would be separated by a space.
        The message from the server back to the client would have an integer code indicating success or error with a return value if necessary.

IV. Implementation:
	+ Files Modified
		test/Makefile
		addrspace.h
		addrspace.cc
		exception.cc
		system.h
		system.cc
		main.cc
		machine.h
		nettest.cc
		main.cc
		createlock.c
		createcondition.c
		start.s
	+ Files added
		test/testvm.c
		vm/swapfile.txt
		test/acquirelockserver.c
		test/releaselockserver.c
		test/waitcvserver.c
		signalcvserver.c
		broadcastserver.c
		createmv.c
		getmv.c
		setmv.c

	+ Data Structures added, and the file they were added to.
		struct PageTableEntry : public TranslationEntry - addrspace.h
		struct IPT : public TranslationEntry - system.h
		struct ServerLock - nettest.cc
		struct ServerCV - nettest.cc
		struct ServerMV - nettest.cc

	+ Data Structures modified, and the file they were added to.
		-For example,
			class Lock		-- in file threads.cc/threads.h
			{
				//. Modified fields.
			}

	+ Functions added and in which file.
		handleIPTMiss - exception.cc
		handleMemoryFull - exception.cc
		RunServer - nettest.cc
		CreateLock - nettest.cc
		AcquireLock - nettest.cc
		ReleaseLock - nettest.cc
		CreateCV - nettest.cc
		Wait - nettest.cc
		Signal - nettest.cc
		Broadcast - nettest.cc
		CreateMV - nettest.cc
		SetMV - nettest.cc
		GetMV - nettest.cc
		CreateMVSyscall - exception.cc
		SetSyscall - exception.cc
		GetSyscall - exception.cc


	+ Functions modified and in which file.
		pageFaultException handling - exception.cc
		ExitSyscall - exception.cc
		RestoreState - addrspace.cc
		Initialize - system.cc
		AddrSpace constructor - addrspace.cc
		CreateLockSyscall - exception.cc
		AcquireSyscall - exception.cc
		ReleaseSyscall - exception.cc
		CreateConditionSyscall - exception.cc
		WaitSyscall - exception.cc
		SignalSyscall - exception.cc
		BroadcastSyscall - exception.cc
		ExceptionHandler - exception.cc

V. Testing:  (For each test case, you must show)
	+ How to test
- How to run the test cases, the commands, the arguments and so on.
	To test parts 1 and 2 you can run the following command: "nachos -P {FIFO | RAND} -x ../test/testvm" from the 'vm' directory.
	The default page replacement policy is FIFO but you can select either RAND or FIFO with the -P flag (i.e. -P RAND)
	To test parts 1 and 2 you can run the following command: "nachos -x ../test/testvm" from the 'vm' directory.
	+ Test Output
 	This executes two matmult's and upon successful completion they will exit with value 7220 and will print these values out.

 	RPCs
 	+How to test
 		Lock RPCs:
            1) In the first terminal window run 'nachos -S -m 0'
            2) In the second terminal window run the following commands:
                    nachos -x ../test/createlock -m 1
                    nachos -x ../test/acquirelockserver -m 2
            3) In the third terminal window run 'nachos -x ../test/acquirelockserver -m 3'
            4) In the second terminal window run 'nachos -x ../test/releaselockserver -m 2'
            5) In the third terminal window run 'nachos -x ../test/releaselockserver -m 3'

        Condition Wait/Signal RPCs:
            1) In the first terminal window run 'nachos -S -m 0'
            2) In the second terminal window run the following commands:
                    nachos -x ../test/createlock -m 1
                    nachos -x ../test/createcondition -m 1
                    nachos -x ../test/waitcvserver -m 1
            3) In the third terminal window run 'nachos -x ../test/signalcvserver -m 2'

        Broadcast RPC:
        	1) In the first terminal window run 'nachos -S -m 0'
        	2) In the second terminal window run the following commands:
        			nachos -x ../test/createlock -m 1
        			nachos -x ../test/createcondition -m 1
        	3) In the third terminal window run 'nachos -x ../test/waitcvserver -m 2'
        	4) In the fourth terminal window run 'nachos -x ../test/waitcvserver -m 3'
        	5) In the fifth terminal window run 'nachos -x ../test/waitcvserver -m 4'
        	6) In the second terminal window run 'nachos -x ../test/broadcastcvserver -m 1'

        Monitor Variables:
        	1) In the first terminal window run 'nachos -S -m 0'
        	2) In the second terminal window run the following commands:
        			nachos -x ../test/createmv -m 1
        			nachos -x ../test/setmv -m 2
        			nachos -x ../test/getmv -m 3

    +Test Output
    	Lock RPCs:
            Message from Machine 1: 0 abc
            Created lock named abc from machine 1
            Message from Machine 2: 2 0
            Acquired lock 0 from machine 2
            Message from Machine 3: 2 0
            Lock 0 is busy so machine 3 will wait
            Message from Machine 2: 3 0
            Releasing lock 0 from machine 2
            Machine 3 is now the owner of lock 0
            Message from Machine 3: 3 0
            Releasing lock 0 from machine 3

        Condition Wait/Signal RPCs:
            Message from Machine 1: 0 abc
            Created lock named abc from machine 1
            Message from Machine 1: 4 def
            Created CV named def from machine 1
            Message from Machine 1: 2 0
            Acquired lock 0 from machine 1
            Message from Machine 1: 6 0 0
            Machine 1 is waiting on lock 0 with condition 0
            Message from Machine 2: 2 0
            Acquired lock 0 from machine 2
            Message from Machine 2: 7 0 0
            Machine 1 has been signalled by CV 0
            Lock 0 is busy so machine 1 will wait
            Message from Machine 2: 3 0
            Releasing lock 0 from machine 2
            Machine 1 is now the owner of lock 0
            Message from Machine 1: 3 0
            Releasing lock 0 from machine 1

        Broadcast RPC:
        	Message from Machine 1: 0 abc
			Created lock named abc from machine 1
			Message from Machine 1: 4 def
			Created CV named def from machine 1
			Message from Machine 2: 2 0
			Acquired lock 0 from machine 2
			Message from Machine 2: 6 0 0
			Machine 2 is waiting on lock 0 with condition 0
			Message from Machine 3: 2 0
			Acquired lock 0 from machine 3
			Message from Machine 3: 6 0 0
			Machine 3 is waiting on lock 0 with condition 0
			Message from Machine 4: 2 0
			Acquired lock 0 from machine 4
			Message from Machine 4: 6 0 0
			Machine 4 is waiting on lock 0 with condition 0
			Message from Machine 1: 2 0
			Acquired lock 0 from machine 1
			Message from Machine 1: 8 0 0
			Machine 2 has been signalled by CV 0
			Lock 0 is busy so machine 2 will wait
			Machine 3 has been signalled by CV 0
			Lock 0 is busy so machine 3 will wait
			Machine 4 has been signalled by CV 0
			Lock 0 is busy so machine 4 will wait
			Message from Machine 1: 3 0
			Releasing lock 0 from machine 1
			Machine 2 is now the owner of lock 0
			Message from Machine 2: 3 0
			Releasing lock 0 from machine 2
			Machine 3 is now the owner of lock 0
			Message from Machine 3: 3 0
			Releasing lock 0 from machine 3
			Machine 4 is now the owner of lock 0
			Message from Machine 4: 3 0
			Releasing lock 0 from machine 4

		Monitor Variables:
			Message from Machine 1: 9 abc
			Created MV named abc from machine 1
			Message from Machine 2: 12 0 10
			MV 0 has been set to 10
			Message from Machine 3: 11 0
			MV 0 has been retrieved with value 10


VI. Discussion:
	+ Experiment expectation.  (What is supposed to happen.)
		After implementing part 1 and 2 (which gets rid of preloading memory) we expected that our user programs would now attempt to look in memory for pages that are not already loaded. Thus the user programs would now case a large amount of page fault exceptions and take longer to run. We do not expect our output for these user programs to change obviously. Matmult was expected to exit with status 7220 and sort was expected to exit with status 1023.


	+ Experiment result.  (What actually happened.)
		Once we implemented parts 1 and 2, our OS attempted to find virtual pages that were needed and not existing in our physical memory. As we expected, our page fault exception handler took care of this performing TLB, IPT, and PageTable looks ups where needed. Also, it was able to handle IPT misses by reading from an executable or swap file in the case of a code page. When physical memory filled up and we needed to load a page in, our exception handler evicts a page based on which eviction policy we are using.
	+ Explanation
		- Explain your experiment result - how it proves what 
		  you were supposed to prove.
		We printed out the IPT and TLB every time a load or eviction occurred. We were able to track each page and make sure we were in fact performing correct demand-paged memory allocation. When we run any amount of instances of matmult or sort, we get the correct exit statuses each time (7220 for matmult and 1023 for sort).

VIII. Miscellaneous:
- Whatever else you want the grader know about your development.  You can create your own subsections headings here.