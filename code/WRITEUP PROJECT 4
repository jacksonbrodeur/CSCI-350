Title: Writeup for Project 4, Fall 2015
Date: 12/1/15
Group:  Jackson Brodeur     jbrodeur@usc.edu
        Dylan Davis         dylandav@usc.edu
        Matthew O'Brien     obrienm@usc.edu
	Yekaterina Glazko   glazko@usc.edu
 
I. Requirements:
	Part 1:
		We must write a user program for each unique entity in the passport office such as customer, application clerk, picture clerk, etc… These user programs will all run as their own process since we Exec all of them (and not fork). In this part, we will use only 1 server to connect all of the entities that we have Execed. The server will connect the various entities together and transfer data between user programs. For example, when a customer approaches a picture clerk, the server will transfer ID numbers and other data between these two user programs rather than have the user programs talk to each other directly. Also, the remote procedure calls (RPCs) that allow the passport to work properly and prevent race conditions are not visible to the user programs. To a client user program or a clerk user program (or any other entity for that matter) the Acquire, Wait, and various other RPCs that are called are seen as simple system calls on the client level.

	Part 2:
		In this part, we must create a distributed server system rather than having only 1 server as we did in Part 1. We may have up to 5 servers in this part and the user programs will pick a random server to communicate with when they need to transfer data. Having multiple servers means that we must change our algorithms in regards to how locks, CVs, and MVs are created and accessed. Since each server has only the variables that they created, we must now make each server communicate with each other. If a server does not have a requested variable, they must message all other servers to see if anyone else has it before creating the requested variable (in Part 1 if the lone server didn’t have a variable then we could safely assume that it did not exist). Simply put, we must create multiple servers and make all of our servers communicate with each other in order to keep track of the various shared variables created by the passport office.

II. Assumptions:
	Our main assumption is that our RPCs will all work as aspected regardless of the fact that they are now RPCs instead of system calls. In other words, any time a user program needs to access shared state such as locks/CVs/MVs they will be able to call the standard system call (Acquire, Signal, Wait, Get, etc..) and they will receive the correct output regardless of the fact that we changed the system calls and shared state to be handled on multiple servers now. This means we should not have to change any logic in our passport office, we must merely change any direct access of variables to the proper RPC.
	We also assumed that the servers would always be consistent in their responses and never drop a request or a response. Thus, if a check was sent by one server to see if any other server had a requested variable, all of the servers would respond eventually.

III. Design:
	We decided to implement only 1 set of MV calls as we would return all the MVs as an array. Even MVs that are only 1 int, such as customersFinished (which keeps track of the total number of customers who have had their passports completed) is returned in an array. To access the variable in that case, you would always access index 0 of the array. For variables used by clerks, like lineCount, you would access the proper index of the MV (in this case the index at the clerks line number).
	Algorithms for our passport office will not change because we assume our RPCs to be correct and return the same values as the system calls we used for previous projects. This is explained in the previous “assumptions” section.
	TODO:WRITE ALGORITHM FOR SERVER COMMUNICATION
	

IV. Implementation:
	+ Files Modified
		In the test directory:
			Makefile

		In the userprog directory:
			syscall.h
			exception.cc
			addrspace.cc
			addrspace.h
			progtest.cc

		In the network directory:
			nettest.cc
			Makefile

		In the machine directory:
			machine.h
			translate.h

		In the threads directory:
			system.h
			system.cc
			main.cc
		
	+ Files added
		In the test directory:
			clerks1.c
			clerks2.c
			customers1.c
			customers2.c
			senators.c
			managers.c
			setup.h
			passportclerk.c
			manager.c
			cashier.c
			pictureclerk.c
			applicationclerk.c

		
	+ Data Structures added, and the file they were added to.
	+ Data Structures modified, and the file they were added to.
		-For example,
			class Lock		-- in file threads.cc/threads.h
			{
				//. Modified fields.
			}

	+ Functions added and in which file.
	+ Functions modified and in which file.

V. Testing:  (For each test case, you must show)
+ How to test
- How to run the test cases, the commands, the arguments and so on.
	+ Test Output
- Describe the testing output. You don't have to dump all the output info. Just make sure your description can exactly reflect your output. The grader of your submission will be wanting to compare the output they get with what you say the output is.
	

VI. Discussion:
	+ Experiment expectation.  (What is supposed to happen.)
		Our expectation is that we will Exec any number (up to the max amount) of each instance in our passport office and the office will return the correct output and make sure all customers are finished. This of course will happen from the server communicating between all of the user programs together and keeping track of all the needed variables.

	+ Experiment result.  (What actually happened.)
	+ Explanation
		- Explain your experiment result - how it proves what 
		  you were supposed to prove.

VIII. Miscellaneous:
- Whatever else you want the grader know about your development.  You can create your own subsections headings here.
